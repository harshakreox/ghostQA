"""
AI Test Case Generation - FINAL FIXED VERSION
Works with your TestAction enum values
"""

from pydantic import BaseModel
from typing import List, Optional
from models import TestCase, TestAction
import os
import json
import requests


class GenerateTestCasesRequest(BaseModel):
    """Request to generate test cases from BRD"""
    brd_content: str
    project_id: Optional[str] = None
    project_context: Optional[str] = None
    base_url: Optional[str] = None


class GeneratedTestCase(BaseModel):
    """A test case generated by AI"""
    name: str
    description: str
    actions: List[TestAction]
    confidence_score: float = 0.0
    notes: Optional[str] = None


class GenerateTestCasesResponse(BaseModel):
    """Response containing generated test cases"""
    test_cases: List[GeneratedTestCase]
    total_generated: int
    brd_summary: str
    suggestions: List[str] = []


class AITestCaseGenerator:
    """Universal AI Test Case Generator"""
    
    def __init__(self):
        """Auto-detect and configure LLM connection"""
        self.api_url = None
        self.model = None
        self.api_type = None
        self.api_key = None
        
        self._detect_llm()
    
    def _detect_llm(self):
        """Auto-detect which LLM service to use"""
        
        # Option 1: Custom LLM_API_URL
        if os.getenv("LLM_API_URL"):
            self.api_url = os.getenv("LLM_API_URL")
            self.model = os.getenv("LLM_MODEL", "local-model")
            self.api_type = os.getenv("LLM_API_TYPE", "openai")
            self.api_key = os.getenv("LLM_API_KEY")
            print(f"[OK] Using custom LLM: {self.api_url}")
            return
        
        # Option 2: Check for Ollama
        try:
            response = requests.get("http://localhost:11434/api/tags", timeout=2)
            if response.status_code == 200:
                self.api_url = "http://localhost:11434/api/generate"
                self.api_type = "ollama"
                
                models_data = response.json().get('models', [])
                available_models = [m['name'] for m in models_data]
                
                preferred_model = os.getenv("OLLAMA_MODEL")
                
                if preferred_model:
                    matching = [m for m in available_models if preferred_model in m]
                    if matching:
                        self.model = matching[0]
                    else:
                        self.model = available_models[0] if available_models else "llama3.1"
                else:
                    self.model = available_models[0] if available_models else "llama3.1"
                
                print(f"[OK] Using Ollama: {self.model}")
                return
        except:
            pass
        
        # Option 3: Check for Anthropic API key
        if os.getenv("ANTHROPIC_API_KEY"):
            self.api_url = "https://api.anthropic.com/v1/messages"
            self.model = "claude-sonnet-4-20250514"
            self.api_type = "anthropic"
            self.api_key = os.getenv("ANTHROPIC_API_KEY")
            print("[OK] Using Anthropic Claude")
            return
        
        raise ValueError("No AI service configured!")
    
    def generate_test_cases(
        self,
        brd_content: str,
        project_context: Optional[str] = None,
        base_url: Optional[str] = None
    ) -> GenerateTestCasesResponse:
        """Generate test cases from BRD"""
        
        prompt = self._build_prompt(brd_content, project_context, base_url)
        
        print(f" Generating test cases with {self.api_type}...")
        ai_response = self._call_llm(prompt)
        
        test_cases = self._parse_response(ai_response)
        brd_summary = self._extract_field(ai_response, "summary")
        suggestions = self._extract_field(ai_response, "suggestions")
        
        return GenerateTestCasesResponse(
            test_cases=test_cases,
            total_generated=len(test_cases),
            brd_summary=brd_summary,
            suggestions=suggestions if isinstance(suggestions, list) else []
        )
    
    def _build_prompt(self, brd_content: str, project_context: Optional[str], base_url: Optional[str]) -> str:
        """Build prompt with EXACT enum values"""
        
        return f"""You are an expert QA automation engineer. Analyze this BRD and generate test cases.

BRD Content:
{brd_content}

{f"Project Context: {project_context}" if project_context else ""}
{f"Application URL: {base_url}" if base_url else ""}

Generate 35-40 test cases covering happy paths, negative scenarios, and edge cases.

Return ONLY valid JSON:
{{
  "summary": "Brief BRD summary",
  "test_cases": [
    {{
      "name": "Test Case Name",
      "description": "What this validates",
      "confidence_score": 0.95,
      "notes": "Assumptions",
      "actions": [
        {{"action": "navigate", "url": "https://example.com", "selector": "", "value": "", "description": "Go to page"}},
        {{"action": "type", "selector": "#username", "value": "testuser", "url": "", "description": "Enter username"}},
        {{"action": "click", "selector": "#login", "value": "", "url": "", "description": "Click login"}},
        {{"action": "assert_visible", "selector": "#dashboard", "value": "", "url": "", "description": "Verify dashboard"}}
      ]
    }}
  ],
  "suggestions": ["Test ideas"]
}}

CRITICAL - Use ONLY these exact action types:
- navigate (go to URL)
- click (click element)  
- type (enter text)
- select (dropdown)
- wait (wait for element)
- hover (mouse over)
- check (checkbox on)
- uncheck (checkbox off)
- assert_visible (verify visible)
- assert_text (verify text)
- assert_url (verify URL)
- screenshot (take screenshot)

Each action needs 5 fields (empty string "" if not used):
- action: EXACT type from list above
- selector: CSS selector
- value: input or expected value
- url: full URL (for navigate)
- description: what it does

Return ONLY JSON, no markdown."""
    
    def _call_llm(self, prompt: str) -> str:
        """Call the configured LLM"""
        
        if self.api_type == "ollama":
            return self._call_ollama(prompt)
        elif self.api_type == "openai":
            return self._call_openai(prompt)
        elif self.api_type == "anthropic":
            return self._call_anthropic(prompt)
        else:
            raise ValueError(f"Unknown API type: {self.api_type}")
    
    def _call_ollama(self, prompt: str) -> str:
        """Call Ollama API"""
        payload = {
            "model": self.model,
            "prompt": prompt,
            "stream": False,
            "options": {"temperature": 0.7}
        }
        response = requests.post(self.api_url, json=payload, timeout=600)
        response.raise_for_status()
        return response.json().get("response", "")
    
    def _call_openai(self, prompt: str) -> str:
        """Call OpenAI-compatible API"""
        payload = {
            "model": self.model,
            "messages": [{"role": "user", "content": prompt}],
            "temperature": 0.7,
            "max_tokens": 8000
        }
        headers = {"Content-Type": "application/json"}
        if self.api_key:
            headers["Authorization"] = f"Bearer {self.api_key}"
        
        response = requests.post(self.api_url, json=payload, headers=headers, timeout=120)
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"]
    
    def _call_anthropic(self, prompt: str) -> str:
        """Call Anthropic Claude API"""
        import anthropic
        client = anthropic.Anthropic(api_key=self.api_key)
        message = client.messages.create(
            model=self.model,
            max_tokens=8000,
            messages=[{"role": "user", "content": prompt}]
        )
        return message.content[0].text
    
    def _parse_response(self, response: str) -> List[GeneratedTestCase]:
        """Parse AI response into test cases"""
        
        try:
            cleaned = response.strip()
            
            if "```json" in cleaned:
                cleaned = cleaned.split("```json")[1].split("```")[0]
            elif "```" in cleaned:
                cleaned = cleaned.split("```")[1].split("```")[0]
            
            cleaned = cleaned.strip()
            
            if not cleaned.startswith("{"):
                start = cleaned.find("{")
                end = cleaned.rfind("}") + 1
                if start != -1 and end > start:
                    cleaned = cleaned[start:end]
            
            data = json.loads(cleaned)
            
            test_cases = []
            for tc_data in data.get("test_cases", []):
                actions = []
                for action_data in tc_data.get("actions", []):
                    # Ensure all 5 fields exist
                    action = TestAction(
                        action=action_data.get("action", "click"),
                        selector=action_data.get("selector", ""),
                        value=action_data.get("value", ""),
                        url=action_data.get("url", ""),
                        description=action_data.get("description", "")
                    )
                    actions.append(action)
                
                test_cases.append(GeneratedTestCase(
                    name=tc_data.get("name", "Untitled Test"),
                    description=tc_data.get("description", ""),
                    actions=actions,
                    confidence_score=float(tc_data.get("confidence_score", 0.8)),
                    notes=tc_data.get("notes", "")
                ))
            
            return test_cases
            
        except Exception as e:
            print(f"[ERR] Parse Error: {str(e)}")
            print(f"Response: {response[:500]}")
            raise Exception(f"Failed to parse response: {str(e)}")
    
    def _extract_field(self, response: str, field: str):
        """Extract a field from JSON response"""
        try:
            cleaned = response.strip()
            if "```json" in cleaned:
                cleaned = cleaned.split("```json")[1].split("```")[0]
            elif "```" in cleaned:
                cleaned = cleaned.split("```")[1].split("```")[0]
            cleaned = cleaned.strip()
            if not cleaned.startswith("{"):
                start = cleaned.find("{")
                end = cleaned.rfind("}") + 1
                if start != -1 and end > start:
                    cleaned = cleaned[start:end]
            
            data = json.loads(cleaned)
            return data.get(field, "" if field == "summary" else [])
        except:
            return "" if field == "summary" else []


def get_test_case_generator():
    """Get configured AI generator"""
    return AITestCaseGenerator()


# File extraction utilities

def extract_text_from_txt(file_path: str) -> str:
    """Extract text from TXT file"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except:
        with open(file_path, 'r', encoding='latin-1') as f:
            return f.read()


def extract_text_from_docx(file_path: str) -> str:
    """Extract text from DOCX file"""
    try:
        from docx import Document
        doc = Document(file_path)
        return '\n'.join([para.text for para in doc.paragraphs])
    except ImportError:
        raise Exception("python-docx not installed. Run: pip install python-docx")
    except Exception as e:
        raise Exception(f"Error reading DOCX: {str(e)}")


def extract_text_from_pdf(file_path: str) -> str:
    """Extract text from PDF file"""
    try:
        import pdfplumber
        with pdfplumber.open(file_path) as pdf:
            return '\n'.join([page.extract_text() for page in pdf.pages])
    except ImportError:
        raise Exception("pdfplumber not installed. Run: pip install pdfplumber")
    except Exception as e:
        raise Exception(f"Error reading PDF: {str(e)}")


def extract_text_from_file(file_path: str) -> str:
    """Extract text from file based on extension"""
    ext = os.path.splitext(file_path)[1].lower()
    
    if ext == '.txt':
        return extract_text_from_txt(file_path)
    elif ext == '.docx':
        return extract_text_from_docx(file_path)
    elif ext == '.pdf':
        return extract_text_from_pdf(file_path)
    else:
        raise Exception(f"Unsupported file format: {ext}")